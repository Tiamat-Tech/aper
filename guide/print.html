<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Getting Started with Aper</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="managing_state.html"><strong aria-hidden="true">2.</strong> Managing State</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="building.html"><strong aria-hidden="true">2.1.</strong> Building a state machine</a></li><li class="chapter-item expanded "><a href="atoms.html"><strong aria-hidden="true">2.2.</strong> Constants and Atoms</a></li><li class="chapter-item expanded "><a href="derive.html"><strong aria-hidden="true">2.3.</strong> Derive macro</a></li><li class="chapter-item expanded "><a href="lists.html"><strong aria-hidden="true">2.4.</strong> Lists</a></li><li class="chapter-item expanded "><a href="designing.html"><strong aria-hidden="true">2.5.</strong> Designing with state machines</a></li><li class="chapter-item expanded "><a href="implementing.html"><strong aria-hidden="true">2.6.</strong> Implementing a new state machine</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Getting Started with Aper</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>Aper</strong> is a Rust library for representing data that can be read and written to by multiple users in real time.</p>
<p>Use-cases of Aper include managing the state of an application with real-time collaboration features and synchronizing the game state of a multiplayer game.</p>
<p>The core <code>aper</code> library implements the underlying data structures and algorithms, but is agnostic to the actual mechanism for transfering data on a network. The crates <code>aper-yew</code> and <code>aper-actix</code> provide a client and server aimed at synchronizing state across multiple <code>WebAssembly</code> clients using <code>WebSockets</code>.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>For Aper to synchronize state, it must be represented as a <strong>state 
machine</strong>. This means that:</p>
<ol>
<li>It implements the <code>StateMachine</code> trait, which has one type argument (<code>Transition</code>) and one method: <code>apply(t: Transition)</code>.</li>
<li><strong>All</strong> changes to its internal state flow through this <code>apply</code> method.</li>
<li>Updates to state are entirely deterministic. They may depend on the current state and any data
that is contained in the transition value, and nothing else.</li>
</ol>
<p>#1 is enforced by Rust's type system, but it's your responsibility to satisfy #2 and #3. In particular,
accessing the current time, non-determistic random number generators, or external data in <code>apply</code> is
a violation of #3.</p>
<h3 id="keeping-state-in-sync"><a class="header" href="#keeping-state-in-sync">Keeping State in Sync</a></h3>
<p>In principle, the way that Aper keeps state in sync is pretty simple: when a client connects, they receive a full copy of the latest copy of the state. Thereafter, they receive a real-time stream of <code>Transition</code>s. Every client receives the same transitions in the same order, so their states are updated in lockstep. <strong>This is why it's important that <code>apply</code> is deterministic.</strong> If it were not, states could become divergent even if they received the same transition stream.</p>
<p>Note that for this model to work, the client can't immediately apply a transition to its local state, because the client doesn't know whether another client is sending the server a transition at the same time. The client has two options:</p>
<ul>
<li>Wait to receive its own transition back from the server, and accept 
the latency associated with it. Depending on the use-case, a few 
hundred milliseconds of latency might be tolerable and the simpler 
model is easier to reason about.</li>
<li>Keep two copies of the state, called <code>optimist</code> and <code>pessimist</code>, as<br />
well as a FIFO queue <code>stash</code> of local transitions. As local 
transitions fire, push them to <code>stash</code> and proactively apply them to 
<code>optimist</code>. <code>optimist</code> is used to render the view, so local 
transitions appear automatically. When the server sends a 
transition, check if it is the next transition in our <code>stash</code>. If 
so, pop it from the <code>stash</code> and apply it to <code>pessimist</code>. Otherwise, 
we apply the server-sent transition to <code>pessimist</code>, then clone it 
and apply every transition in the <code>stash</code> to the clone. This clone 
becomes the new value of <code>optimist</code>, and the old value is discarded.</li>
</ul>
<p>Aper implements both of these approaches.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="managing-state"><a class="header" href="#managing-state">Managing State</a></h1>
<p>In this section, we will look at the core <code>aper</code> crate
and how it represents data. Once we have a solid handle
on how data is represented, we will turn to synchronizing
it across the network in the next section.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="building-a-state-machine"><a class="header" href="#building-a-state-machine">Building a state machine</a></h1>
<p>To solidify the concept of state machines, let's start with a simple
example. Here's a simple data structure representing a counter. It stores
an integer and gives us methods to modify it.</p>
<pre><code class="language-rust noplaypen">struct Counter {value: i64}

impl Counter {
    pub fn add(&amp;mut self, i: i64) {
        self.value += i;
    }

    pub fn subtract(&amp;mut self, i: i64) {
        self.value -= i;
    }

    pub fn reset(&amp;mut self, i: i64) {
        self.value = 0;
    }
}

<span class="boring">fn main() {}
</span></code></pre>
<p>By inspecting the code, you can see that <code>Counter</code> satisfies 
<a href="introduction.html">condition #3</a> of a state machine in Aper:
its updates are deterministic. It does <em>not</em>, however, satisfy 
conditions #1 and #2: it does not implement <code>StateMachine</code>, and 
methods other than <code>apply</code> mutate the state.</p>
<p>(By the way, a good way to check if #2 is satisfied is to look for 
which methods take <code>&amp;mut self</code>. In an Aper state machine, <strong>only</strong> 
<code>apply</code> should need a mutable reference to <code>self</code>.)</p>
<p>We can turn <code>Counter</code> into a state machine like this:</p>
<pre><code class="language-rust noplaypen">use aper::{StateMachine, Transition};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug, Clone)]
struct Counter {value: i64}

#[derive(Transition, Serialize, Deserialize, Debug, Clone, PartialEq)]
enum CounterTransition {
   Add(i64),
   Subtract(i64),
   Reset,
}

impl StateMachine for Counter {
    type Transition = CounterTransition;

    fn apply(&amp;mut self, event: CounterTransition) {
        match event {
            CounterTransition::Add(i) =&gt; {
                self.value += i;
            }
            CounterTransition::Subtract(i) =&gt; {
                self.value -= i;
            }
            CounterTransition::Reset =&gt; {
                self.value = 0;
            }
        }
    }
}
<span class="boring">fn main() {}
</span></code></pre>
<p>Now, any attempt to modify the state of the counter must flow through 
<code>apply</code> as a <code>CounterTransition</code>. We could use <code>CounterTransition</code>'s 
constructors directly, but the idiomatic approach that Aper encourages 
is to implement methods with the same signatures as our original 
modifiers but that return the <code>Transition</code> type:</p>
<pre><code class="language-rust noplaypen"><span class="boring">use aper::{StateMachine, Transition};
</span><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct Counter {value: i64}
</span><span class="boring">
</span><span class="boring">#[derive(Transition, Serialize, Deserialize, Debug, Clone, PartialEq)]
</span><span class="boring">enum CounterTransition {
</span><span class="boring">   Add(i64),
</span><span class="boring">   Subtract(i64),
</span><span class="boring">   Reset,
</span><span class="boring">}
</span><span class="boring">
</span>impl Counter {
    pub fn add(&amp;self, i: i64) -&gt; CounterTransition {
        CounterTransition::Add(i)
    }

    pub fn subtract(&amp;self, i: i64) -&gt; CounterTransition {
        CounterTransition::Subtract(i)
    }

    pub fn reset(&amp;self, i: i64) -&gt; CounterTransition {
        CounterTransition::Reset
    }
}
<span class="boring">fn main() {}
</span></code></pre>
<p>Notice how these no longer require a mutable reference to <code>self</code>, since they do not actually make any changes, they just return an object <em>representing</em> the change. In fact, in this case they don't
even <em>read</em> from <code>self</code>, but that would be allowed and comes in
handy when we deal with more complex update logic.</p>
<p>I started by showing you how to implement your own state machine 
because I wanted you to see that it isn't
scary, but implementing state machines from scratch isn't the only way 
to use Aper. In the next few sections,
I'll show you how to build state machines by composing together 
primitives that Aper provides.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="constants-and-atoms"><a class="header" href="#constants-and-atoms">Constants and Atoms</a></h1>
<p>Another way to build state machines is by combining other state 
machines. Aper ships with some built-in state machines which provide
common patterns for managing state.</p>
<p>The simplest state machine is a <code>Constant</code>. It's a state machine whose 
transition has no exposed constructor, and therefore which can never 
be modified once it's created. It takes an initial value, and then 
stubbornly keeps that state for the rest of its life.</p>
<pre><code class="language-rust noplaypen">use aper::data_structures::Constant;

fn main() {
    // Construct a constant representing an i64.
    let int_constant = Constant::new(5);
    assert_eq!(&amp;5, int_constant.value());

    // Construct a constant representing a String.
    let string_constant = Constant::new(&quot;Hi Aper&quot;.to_string());

    assert_eq!(&quot;Hi Aper&quot;, string_constant.value().as_str());
}
</code></pre>
<p>An <code>Atom</code> is similar to a <code>Constant</code>, except that it has a transition called <code>ReplaceAtom</code>.</p>
<p>It represents a value that can only be changed by replacing it entirely.</p>
<pre><code class="language-rust noplaypen">use aper::data_structures::Atom;
use aper::StateMachine;

fn main() {
    let mut atom = Atom::new(5);

    // Construct a new `ReplaceAtom` transition.
    let transition = atom.replace(6);

    // Remember, calling `.replace` does not actually change any
    // state -- only a call to `.apply` can do that.
    assert_eq!(&amp;5, atom.value());
    
    atom.apply(transition);

    // Now the change takes effect.
    assert_eq!(&amp;6, atom.value());
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="derive-macro"><a class="header" href="#derive-macro">Derive macro</a></h1>
<p>In the last section, we were introduced to the <code>Atom</code> state machine.
If networks were infinitely fast, <code>Atom</code> might be the only state 
machine we ever needed: every time a user changed the state, we'd 
just send the new entire state to every other user and be done with it.</p>
<p>In practice, the reason we can't do this is that without infinitely 
fast networks, it's possible for different users to make conflicting 
changes. For example, let's say we represented a to-do list item
as a state machine by wrapping it in an <code>Atom</code>:</p>
<pre><code class="language-rust noplaypen">use aper::data_structures::Atom;

struct ToDoListItem {
    done: bool,
    label: String,
}

type ToDoListAtom = Atom&lt;ToDoListItem&gt;;
</code></pre>
<p>Imagine that you and I are using a shared to-do list app that took
this approach to representing state. Suppose we both modified this 
item at the same time: you marked it as <strong>done</strong>, and I fixed a typo 
in the <strong>label</strong>. Your edit hits the server first, so the server's 
state is briefly updated with the item marked as <strong>done</strong>. But my 
transition was sent at the same time as yours, and because an Atom 
update carries with it the entire value, it includes the old state
of <strong>done</strong>. When my edit is applied, it has the effect of undoing
yours. <a href="https://www.youtube.com/watch?v=gcyOoPDlSuU">How rude</a>.</p>
<p>To avoid this, we can push <code>Atom</code>s deeper down into the data 
structure. Aper facilitates this with a <code>derive</code> macro:</p>
<pre><code class="language-rust noplaypen">use aper::StateMachine;
use aper::data_structures::Atom;
use serde::{Serialize, Deserialize};

#[derive(StateMachine, Serialize, Deserialize, Debug, Clone, PartialEq)]
struct ToDoListItem {
    done: Atom&lt;bool&gt;,
    label: Atom&lt;String&gt;,
}

impl ToDoListItem {
    pub fn new(label: String) -&gt; Self {
        ToDoListItem {
            done: Atom::new(false),
            label: Atom::new(label),
        }
    }
}
</code></pre>
<p>Now, we can represent these same transitions in a way that they don't 
conflict.</p>
<pre><code class="language-rust noplaypen"><span class="boring">use aper::StateMachine;
</span><span class="boring">use aper::data_structures::Atom;
</span><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">
</span><span class="boring">#[derive(StateMachine, Serialize, Deserialize, Debug, Clone, PartialEq)]
</span><span class="boring">struct ToDoListItem {
</span><span class="boring">    done: Atom&lt;bool&gt;,
</span><span class="boring">    label: Atom&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ToDoListItem {
</span><span class="boring">    pub fn new(label: String) -&gt; Self {
</span><span class="boring">        ToDoListItem {
</span><span class="boring">            done: Atom::new(false),
</span><span class="boring">            label: Atom::new(label),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut item = ToDoListItem::new(&quot;Buy gorceries&quot;.to_string());

    assert_eq!(&quot;Buy gorceries&quot;, item.label().value());
    assert_eq!(&amp;false, item.done().value());

    let mark_done = item.map_done(|d| d.replace(true));
    let fix_typo = item.map_label(|d| d.replace(&quot;Buy groceries&quot;.to_string()));

    // Unlike with `ToDoListAtom`, the order in which the transitions 
    // are applied here does not matter.
    item.apply(mark_done);
    item.apply(fix_typo);

    assert_eq!(&quot;Buy groceries&quot;, item.label().value());
    assert_eq!(&amp;true, item.done().value());
}
</code></pre>
<p>The methods <code>map_done</code> and <code>map_label</code> are generated by the derive 
macro by prepending <code>map_</code> to each field. They take a single argument, 
which is a function from the type of that field (e.g. <code>Atom&lt;bool&gt;</code>) to 
a type of that field's transition (<code>ReplaceAtom&lt;bool&gt;</code>). They return a 
transition that can be applied to the parent struct (<code>ToDoListItem</code>), 
which combines the transition you constructed in the map with an 
indication of which field of the parent struct it is to be applied to.</p>
<p>To better understand this approach, it might be good to understand 
what we <em>can't</em> do. For one thing, we can't apply the field's 
<code>ReplaceAtom</code> transition directly to the <code>ToDoListItem</code> struct that
contains it:</p>
<pre><code class="language-rust ignore">fn main() {
    let mut item = ToDoListItem::new(&quot;Buy gorceries&quot;.to_string());

    let mark_done = item.done().replace(true);

    // This will fail to compile because `done()` exposes a non-mutable
    // borrow of the Atom, but `apply()` requires a mutable borrow.
    item.done().apply(mark_done);
}
</code></pre>
<p>Nor can we apply the <code>Atom</code>'s state change directly to the 
<code>ToDoListItem</code>:</p>
<pre><code class="language-rust ignore">fn main() {
    let mut item = ToDoListItem::new(&quot;Buy gorceries&quot;.to_string());

    let mark_done = item.done().replace(true);

    // This will fail to compile because `mark_done` is a
    // `ReplaceAtom&lt;bool&gt;` but `item.apply()` expects a
    // `ToDoListItemTransition`.
    item.apply(mark_done);
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="lists"><a class="header" href="#lists">Lists</a></h1>
<p>Another built-in data structure is the <code>List</code>. Lists are ordered sequence that you can iterate over, and arbitrarily insert/remove from. The values in a list are themselves state machines (if you never want to modify the inner state of values on a list, you can use <code>Constant</code> as a wrapper around the values.)</p>
<p>Let's use the <code>ToDoListItem</code> from the last section to create a <code>ToDoList</code></p>
<pre><code class="language-rust noplaypen">use aper::data_structures::List;
<span class="boring">use aper::StateMachine;
</span><span class="boring">use aper::data_structures::Atom;
</span><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">use std::default::Default;
</span><span class="boring">
</span><span class="boring">#[derive(StateMachine, Serialize, Deserialize, Debug, Clone, PartialEq)]
</span><span class="boring">struct ToDoListItem {
</span><span class="boring">    done: Atom&lt;bool&gt;,
</span><span class="boring">    label: Atom&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ToDoListItem {
</span><span class="boring">    pub fn new(label: String) -&gt; Self {
</span><span class="boring">        ToDoListItem {
</span><span class="boring">            done: Atom::new(false),
</span><span class="boring">            label: Atom::new(label),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn main() {
	let mut to_do_list: List&lt;ToDoListItem&gt; = List::default();

	// Initially, the list is empty. We need to add things to it.

	// Append generates and returns an identifier which we can later
	// use to identify the record.
	// The methods `append`, `prepend`, and `insert` of `List`
	// return a `(id, transition)` pair, where the `id` can be used
	// to refer to the element after it has been inserted.
	let (dog_food_id, dog_food_transition) = to_do_list.append(
			ToDoListItem::new(&quot;Get dog food&quot;.to_string())
	);

	to_do_list.apply(dog_food_transition);

	let (lunch_id, lunch_transition) = to_do_list.append(
			ToDoListItem::new(&quot;Make lunch&quot;.to_string())
	);

	to_do_list.apply(lunch_transition);

	let emphasize_dog_food = to_do_list.map_item(dog_food_id,
		|it| it.map_label(|lbl| lbl.replace(&quot;Get DOG FOOD!&quot;.to_string()
		)));

	to_do_list.apply(emphasize_dog_food);

	let mark_lunch_done = to_do_list.map_item(lunch_id,
		|it| it.map_done(|done| done.replace(true)));
}
</code></pre>
<p>If this method of calling <code>map_*</code> seems tedious or doesn't quite 
“click”, don't worry. Later, when we actually implement the UI, we 
will see a design patter that allows us to eliminate the need for 
<code>map_*</code> methods.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="designing-with-state-machines"><a class="header" href="#designing-with-state-machines">Designing with state machines</a></h1>
<p>When working with state machines, situations often come up where there 
are multiple ways to represent the same state. We saw this already 
with the <code>ToDoListItem</code> <a href="derive.html">example</a>, where the state could be 
either:</p>
<ol>
<li>A single <code>Atom</code> of a <code>ToDoListItem</code> struct with primitive types for 
fields, or</li>
<li>A struct of two <code>Atom</code> fields, with each atom containing a 
primitive type, implementing <code>StateMachine</code> through the <code>derive</code> 
macro.</li>
</ol>
<p>Both approaches are functionally equivalent when it comes to 
representing data <em>at rest</em>. They differ only in how merges are 
handled when (in this case) multiple fields are modified at the same 
time. For the to-do list example, we decided that #2 was the right 
approach, but there may be other data types for which #1 is the best 
approach.</p>
<p>This points to an important aspect of Aper that is central to its 
design philosophy. Aper's focus is on helping you to express the 
<strong>semantics of merging concurrent modifications</strong> to the same data 
structure. The underlying data structures Aper provides are just a 
means to that end.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="implementing-a-new-state-machine"><a class="header" href="#implementing-a-new-state-machine">Implementing a new state machine</a></h1>
<p>So far, aside from the <a href="building.html">opening example</a>, we've created
state machines by composing primitive, pre-built
state machines and using the derive macro. For total flexibility, you 
can also implement your own. This may be useful when you want to
implement a shared data structure that can't be expressed efficiently 
with Aper's built-in data structures, or when your program state
involves complex update logic. A great example of the latter is games,
in which the games rules determine how state is updated.</p>
<p>To demonstrate this, let's implement a state machine representing
the game Tic Tac Toe.</p>
<p>Tic Tac Toe has two players, <strong>X</strong> and <strong>O</strong>, which we can represent
as an enum:</p>
<pre><code class="language-rust noplaypen">use serde::{Serialize, Deserialize};

#[derive(Clone, Copy, Serialize, Deserialize, Debug, PartialEq)]
enum Player { X, O }
</code></pre>
<p>There are three possible states to a tic tac toe game:</p>
<ol>
<li>The game is underway and waiting on a particular player to play 
next.</li>
<li>The game has ended with a winner.</li>
<li>The game has ended in a tie, because the board is filled but no
player has won.</li>
</ol>
<p>We will represent all three of these with the <code>GameStatus</code> struct:</p>
<pre><code class="language-rust noplaypen"><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">#[derive(Clone, Copy, Serialize, Deserialize, Debug, PartialEq)]
</span><span class="boring">enum Player { X, O }
</span><span class="boring">
</span>#[derive(Clone, Copy, Serialize, Deserialize, Debug, PartialEq)]
enum GameStatus {
    /// Indicates that the game is ongoing and the provided
    /// player is next.
    NextPlayer(Player),

    /// Indicates that the game has been won by the given player.
    Won(Player),

    /// Indicates that the game has ended in a tie.
    Tie,
}
</code></pre>
<p>The board is a 3x3 grid. For simplicity, let's flatten this into
an array with 9 entries. Each grid space can either be an <code>X</code>,
an <code>O</code>, or empty. We can thus represent each grid cell as an
<code>Option&lt;Player&gt;</code>.</p>
<p>The board cells correspond to indices in the flattened grid as
follows:</p>
<pre><code class="language-plain">0 | 1 | 2
--+---+--
3 | 4 | 5
--+---+--
6 | 7 | 8
</code></pre>
<p>Combining the <code>GameStatus</code> with the grid, we have a game state that
looks like this:</p>
<pre><code class="language-rust noplaypen"><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">#[derive(Clone, Copy, Serialize, Deserialize, Debug, PartialEq)]
</span><span class="boring">enum Player { X, O }
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Serialize, Deserialize, Debug, PartialEq)]
</span><span class="boring">enum GameStatus {
</span><span class="boring">    /// Indicates that the game is ongoing and the provided
</span><span class="boring">    /// player is next.
</span><span class="boring">    NextPlayer(Player),
</span><span class="boring">
</span><span class="boring">    /// Indicates that the game has been won by the given player.
</span><span class="boring">    Won(Player),
</span><span class="boring">
</span><span class="boring">    /// Indicates that the game has ended in a tie.
</span><span class="boring">    Tie,
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Serialize, Deserialize, Clone, Debug)]
struct TicTacToe {
    /// The current state of the board as a flattened 3x3 grid.
    board: [Option&lt;Player&gt;; 9],

    /// The next player to play, or `None` if the game has ended.
    status: GameStatus,
}
</code></pre>
<p>Next, we need to implement some of the game logic. We need to be
able to construct a new game, and also to be able to check if a
player has won or if the game has ended in a tie.</p>
<pre><code class="language-rust noplaypen"><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">#[derive(Clone, Copy, Serialize, Deserialize, Debug, PartialEq)]
</span><span class="boring">enum Player { X, O }
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Serialize, Deserialize, Debug, PartialEq)]
</span><span class="boring">enum GameStatus {
</span><span class="boring">    /// Indicates that the game is ongoing and the provided
</span><span class="boring">    /// player is next.
</span><span class="boring">    NextPlayer(Player),
</span><span class="boring">
</span><span class="boring">    /// Indicates that the game has been won by the given player.
</span><span class="boring">    Won(Player),
</span><span class="boring">
</span><span class="boring">    /// Indicates that the game has ended in a tie.
</span><span class="boring">    Tie,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Clone, Debug)]
</span><span class="boring">struct TicTacToe {
</span><span class="boring">    /// The current state of the board as a flattened 3x3 grid.
</span><span class="boring">    board: [Option&lt;Player&gt;; 9],
</span><span class="boring">
</span><span class="boring">    /// The next player to play, or `None` if the game has ended.
</span><span class="boring">    status: GameStatus,
</span><span class="boring">}
</span><span class="boring">
</span>impl TicTacToe {
    pub fn new() -&gt; TicTacToe {
        TicTacToe {
            // Start with an empty board.
            board: [None; 9],
            // We'll default to player `O` going first.
            status: GameStatus::NextPlayer(Player::O),
        }
    }

    /// Given an array of three grid indices, check whether
    /// the same player has a mark in all three. If so, return
    /// the value of that player. Otherwise, return `None`.
    fn check_seq(&amp;self, seq: &amp;[usize; 3]) -&gt; Option&lt;Player&gt; {
        let v1 = self.board[seq[0]]?;
        let v2 = self.board[seq[1]]?;
        let v3 = self.board[seq[2]]?;

        if (v1 == v2) &amp;&amp; (v2 == v3) {
            Some(v1)
        } else {
            None
        }
    }

    /// Return the value of the player who has won if the
    /// game has ended, or else return `None`.
    fn winner(&amp;self) -&gt; Option&lt;Player&gt; {
        // To win tic tac toe, a player must occupy every
        // cell in either a column, row, or diagonal. There
        // are eight sets of three cells we need to check.
        let seq_to_check: [[usize; 3]; 8] = [
            // Three rows.
            [0, 1, 2],
            [3, 4, 5],
            [6, 7, 8],
            // Three columns.
            [0, 3, 6],
            [1, 4, 7],
            [2, 5, 8],
            // Two diagonals.
            [0, 4, 8],
            [2, 4, 6],
        ];

        for seq in &amp;seq_to_check {
            let result = self.check_seq(seq);
            if result.is_some() {
                return result;
            }
        }

        None
    }

    /// Return `true` if the game has ended in a tie because
    /// there are no empty grid cells available to play.
    fn tie(&amp;self) -&gt; bool {
        self.board.iter().all(|d| d.is_some())
    }
}
</code></pre>
<p>The last step is to make <code>TicTacToe</code> a valid <code>StateMachine</code>.
We'll start by creating the transition type, <code>TicTacToeMove</code>.
Usually transition types are <code>enum</code>s, but they don't have to be.
In the case of Tic Tac Toe, there's only one type of move a
player can make: to make their mark in an available grid space.
We represent this one-and-only play with a <code>TicTacToeMove</code> struct,
referencing the cell in play by the same flattened numbering
scheme we used to implement the grid as a flat list.</p>
<pre><code class="language-rust noplaypen"><span class="boring">use serde::{Serialize, Deserialize};
</span>use aper::Transition;
#[derive(Transition, Serialize, Deserialize, Clone, Debug, PartialEq)]
struct TicTacToeMove(usize);
</code></pre>
<p>Finally, we can implement <code>StateMachine</code> for <code>TicTacToe</code>, using
<code>TicTacToeMove</code> as the transition.</p>
<pre><code class="language-rust noplaypen"><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">#[derive(Clone, Copy, Serialize, Deserialize, Debug, PartialEq)]
</span><span class="boring">enum Player { X, O }
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Serialize, Deserialize, Debug, PartialEq)]
</span><span class="boring">enum GameStatus {
</span><span class="boring">    /// Indicates that the game is ongoing and the provided
</span><span class="boring">    /// player is next.
</span><span class="boring">    NextPlayer(Player),
</span><span class="boring">
</span><span class="boring">    /// Indicates that the game has been won by the given player.
</span><span class="boring">    Won(Player),
</span><span class="boring">
</span><span class="boring">    /// Indicates that the game has ended in a tie.
</span><span class="boring">    Tie,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Clone, Debug)]
</span><span class="boring">struct TicTacToe {
</span><span class="boring">    /// The current state of the board as a flattened 3x3 grid.
</span><span class="boring">    board: [Option&lt;Player&gt;; 9],
</span><span class="boring">
</span><span class="boring">    /// The next player to play, or `None` if the game has ended.
</span><span class="boring">    status: GameStatus,
</span><span class="boring">}
</span><span class="boring">impl TicTacToe {
</span><span class="boring">    pub fn new() -&gt; TicTacToe {
</span><span class="boring">        TicTacToe {
</span><span class="boring">            // Start with an empty board.
</span><span class="boring">            board: [None; 9],
</span><span class="boring">            // We'll default to player `O` going first.
</span><span class="boring">            status: GameStatus::NextPlayer(Player::O),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Given an array of three grid indices, check whether
</span><span class="boring">    /// the same player has a mark in all three. If so, return
</span><span class="boring">    /// the value of that player. Otherwise, return `None`.
</span><span class="boring">    fn check_seq(&amp;self, seq: &amp;[usize; 3]) -&gt; Option&lt;Player&gt; {
</span><span class="boring">        let v1 = self.board[seq[0]]?;
</span><span class="boring">        let v2 = self.board[seq[1]]?;
</span><span class="boring">        let v3 = self.board[seq[2]]?;
</span><span class="boring">
</span><span class="boring">        if (v1 == v2) &amp;&amp; (v2 == v3) {
</span><span class="boring">            Some(v1)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Return the value of the player who has won if the
</span><span class="boring">    /// game has ended, or else return `None`.
</span><span class="boring">    fn winner(&amp;self) -&gt; Option&lt;Player&gt; {
</span><span class="boring">        // To win tic tac toe, a player must occupy every
</span><span class="boring">        // cell in either a column, row, or diagonal. There
</span><span class="boring">        // are eight sets of three cells we need to check.
</span><span class="boring">        let seq_to_check: [[usize; 3]; 8] = [
</span><span class="boring">            // Three rows.
</span><span class="boring">            [0, 1, 2],
</span><span class="boring">            [3, 4, 5],
</span><span class="boring">            [6, 7, 8],
</span><span class="boring">            // Three columns.
</span><span class="boring">            [0, 3, 6],
</span><span class="boring">            [1, 4, 7],
</span><span class="boring">            [2, 5, 8],
</span><span class="boring">            // Two diagonals.
</span><span class="boring">            [0, 4, 8],
</span><span class="boring">            [2, 4, 6],
</span><span class="boring">        ];
</span><span class="boring">
</span><span class="boring">        for seq in &amp;seq_to_check {
</span><span class="boring">            let result = self.check_seq(seq);
</span><span class="boring">            if result.is_some() {
</span><span class="boring">                return result;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Return `true` if the game has ended in a tie because
</span><span class="boring">    /// there are no empty grid cells available to play.
</span><span class="boring">    fn tie(&amp;self) -&gt; bool {
</span><span class="boring">        self.board.iter().all(|d| d.is_some())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">#[derive(Transition, Serialize, Deserialize, Clone, Debug, PartialEq)]
</span><span class="boring">struct TicTacToeMove(usize);
</span><span class="boring">
</span>use aper::{StateMachine, Transition};

impl StateMachine for TicTacToe {
    type Transition = TicTacToeMove;
    
    fn apply(&amp;mut self, play: TicTacToeMove) {
        let this_player = if let GameStatus::NextPlayer(this_player)
                = self.status {
            this_player
        } else {
            // The game has already ended, don't accept another play.
            return;
        };
        let TicTacToeMove(play_index) = play;
        if self.board[play_index].is_some() {
            // Can't play over something that has already been played!
            return;
        }
        // Insert this play into the board.
        self.board[play_index] = Some(this_player);
        
        // Check if the game has ended.
        if let Some(winner) = self.winner() {
            self.status = GameStatus::Won(winner);
            return;
        } else if self.tie() {
            self.status = GameStatus::Tie;
            return;
        }

        // Update the next player.
        if Player::X == this_player {
            self.status = GameStatus::NextPlayer(Player::O);
        } else {
            self.status = GameStatus::NextPlayer(Player::X);
        }
    }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
