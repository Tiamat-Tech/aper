<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Building a Multiplayer WebAssembly Game in Rust</title>

        <link rel="stylesheet" href="dist/reset.css">
        <link rel="stylesheet" href="dist/reveal.css">
        <link rel="stylesheet" href="dist/theme/solarized.css" id="theme">

        <!-- Theme used for syntax highlighted code -->
        <link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">

        <style>
            * {text-transform: none !important;}

            strong {
                color: #ab1768;
            }

            .hljs-ln-numbers {
                display: none;
            }

            .reveal pre code {
                max-height: 650px;
            }
        </style>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section data-markdown>
                    ## Building a Multiplayer WebAssembly Game in Rust

                    Paul Butler ([@paulgb](https://twitter.com/paulgb)) / [Rust Berlin](https://berline.rs/2021/03/23/rust-and-tell.html) / March 2021
                </section>
                <section>
                    <video data-autoplay src="media/demo.mov"></video>
                </section>
                <section data-markdown>
                    ## Goal
                    
                    **Share state** between **multiple instances** of a web app, in **real time**.
                </section>
                <section data-markdown>
                    ## Use Cases

                    - Collaborative editors (Figma, Google Apps)
                    - Multiplayer games
                </section>
                <section data-markdown>
                    ## Idea

                    1. Record every state change into an ordered stream.
                    2. Broadcast that stream on every client, in the same order.
                </section>
                <section data-markdown>
                    ## (one small problem)
                </section>
                <section>
                    <img src="media/aper-sketch.svg" style="width: 800px;" />
                </section>
                <section data-markdown>
                    Capture **user intent**, not **raw actions**.
                </section>
                <section>
                    <img src="media/aper-sketch-intent.svg" style="width: 800px;" />
                </section>
                <section data-markdown>
                    What if we had a generic data structure library that could **express user intent**
                    and **represent it as data**?
                </section>
                <section>
                    <h1>Introducing Aper</h1>
                    <img src="media/ape.svg" style="width: 400px;" />
                </section>
                <section data-markdown>
                    ## Structure

                    1. `aper` core
                        - Data structures and `StateMachine` trait.
                    2. WebSocket client/server implementation:
                        - `aper-actix`
                            - [Actix](https://actix.rs/) service for synchronizing state over WebSocket.
                        - `aper-yew`
                            - [Yew](https://yew.rs/docs/en/) component that renders a view based on shared state.
                </section>
                <section>
                    <pre><code data-trim class="language-rust" data-line-numbers="1-5|2|4|1-5">
pub trait StateMachine {
    type Transition;

    fn apply(&mut self, transition: Self::Transition);
}
                    </code></pre>
                </section>
                <section data-markdown>
                    **Implementing `StateMachine`**

                    1. Only `apply()` is allowed to modify state.
                    2. Calls to `apply()` must be deterministic.
                </section>

                <section>
                    <pre><code data-trim class="language-rust" data-line-numbers="2-5|7-9|12-15|18-21">
#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq)]
pub enum Player {
    Brown,
    Teal
}

pub const BOARD_ROWS: usize = 6;
pub const BOARD_COLS: usize = 7;
pub type Board = [[Option&lt;Player&gt;; BOARD_COLS]; BOARD_ROWS];

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq)]
pub enum PlayState {
    NextTurn(Player),
    Winner(Player)
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct DropFourGame {
    board: Board,
    state: PlayState
}
                    </code></pre>
                </section>

                <section>
                    <pre><code data-trim class="language-rust" data-line-numbers="2-5|8|10|12-15|16-19|20">
#[derive(Transition, Serialize, Deserialize, Clone, PartialEq)]
pub enum DropFourGameTransition {
    Drop(usize),
    Reset
}

impl StateMachine for DropFourGame {
    type Transition = TransitionEvent&lt;DropFourGameTransition&gt;;

    fn apply(&mut self, event: Self::Transition) {
        match (self.state, event.transition) {
            (PlayState::NextTurn(p),
                DropFourGameTransition::Drop(c)) => {
                // Handle a player taking a turn.
            }
            (PlayState::Winner(p),
                DropFourGameTransition::Reset) => {
                // Handle a player starting a new game.
            }
            _ => {}
        }
    }
}
                    </code></pre>
                </section>

                <section>
                    <pre><code data-trim class="language-rust" data-line-numbers="1|2|3|6-7|8|10|5,8,10">
(PlayState::NextTurn(p), DropFourGameTransition::Drop(c)) => {
    if let Some(insert_row) = self.lowest_open_row(c) {
        self.board[insert_row][c] = Some(p);

        self.state =
            if let Some(winner) = self.check_winner_at(
                    insert_row as i32, c as i32) {
                PlayState::Winner(winner)
            } else {
                PlayState::NextTurn(p.other())
            };
    }
}
                    </code></pre>
                </section>


                <section>
                    <pre><code data-trim class="language-rust" data-line-numbers="1-4|2|3">
(PlayState::Winner(p), DropFourGameTransition::Reset) => {
    self.board = Default::default();
    self.state = PlayState::NextTurn(p.other());
}
                    </code></pre>
                </section>


                <section>
                    <pre><code data-trim class="language-rust" data-line-numbers="1-7|1|3|6">
use aper_actix::ServerBuilder;

impl StateProgram&lt;DropFourGameTransition&gt; for DropFourGame {}

fn main() -> std::io::Result&lt;()&gt; {
    ServerBuilder::new(DropFourGame::default()).serve()
}
                    </code></pre>
                </section>

                <section>
                    <pre><code data-trim class="language-rust" data-line-numbers="1-23|1|2-3|5-6|7-21|6,13,17-18">
impl View for GameView {
    type Callback = DropFourGameTransition;
    type State = DropFourGame;

    fn view(&self, state: &Self::State,
            context: &ViewContext&lt;Self::Callback&gt;) -&gt; Html {
        return html! {
            &lt;div class="main"&gt;
                &lt;h1&gt;{"Drop Four"}&lt;/h1&gt;
                &lt;BoardComponent
                    state=state.clone()
                    callback={
                        context.callback.reform(Some).clone()
                    } /&gt;
                &lt;p&gt;{self.view_state_text(state.state())}&lt;/p&gt;
                &lt;button onclick={
                    context.callback.reform(
                        |_| Some(DropFourGameTransition::Reset))
                }&gt;{"New Game"}&lt;/button&gt;
            &lt;/div&gt;
        };
    }
}     
                    </code></pre>
                </section>

                <section data-markdown>
                    # Thanks!

                    - Me: Paul Butler ([@paulgb](https://twitter.com/paulgb))
                    - Aper: [aper.dev](https://aper.dev/)
                    - GitHub: [aper-dev/aper](https://github.com/aper-dev/aper)
                        - Drop Four: [examples/drop-four](https://github.com/aper-dev/aper/tree/main/examples/drop-four)
                    - Slides: [aper.dev/2021-rust-and-tell](https://aper.dev/2021-rust-and-tell/)
                </section>
                <section>
                    <section data-markdown>
                        ## Appendix: CRDTs
                    </section>
                    <section data-markdown>
                        ## Conflict-free replicated data type (CRDT)

                        - Supports decentralized/peer-to-peer architecture üòä
                        - Can represent nested types (e.g. arbitrary JSON) üòÅ
                        - Quality JS libraries ([yjs](https://github.com/yjs/yjs), [automerge](https://github.com/automerge/automerge)) üòâ
                        - Memory footprint increases monotonically with each edit üòû
                    </section>
                    <section data-markdown>
                        ## CRDTs vs. State Machines

                        - In **CRDTs** the state is a function of an *unordered set* of messages.
                        - In **state machines**, the state is a function of an *ordered list* of messages.
                    </section>
                    <section data-markdown>
                        <textarea data-template>
                            ## CRTDs in Practice

                            - Figma ‚Äúisn't using true CRDTs‚Äù[<sup>1</sup>](https://www.figma.com/blog/how-figmas-multiplayer-technology-works/)
                            - Excalidraw ‚Äú[doesn't] use an off the shelf crdt because we are willing to lose some mergeable updates in exchange for less surprising ux‚Äù[<sup>2</sup>](https://twitter.com/sebastienlorber/status/1244289245923155968)
                            - Room Service: ‚ÄúCRDTs aren‚Äôt the best for multiplayer‚Äù[<sup>3</sup>](https://www.roomservice.dev/)
                        </textarea>
                    </section>
                </section>
            </div>
        </div>

        <script src="dist/reveal.js"></script>
        <script src="plugin/notes/notes.js"></script>
        <script src="plugin/markdown/markdown.js"></script>
        <script src="plugin/highlight/highlight.js"></script>
        <script>
            // More info about initialization & config:
            // - https://revealjs.com/initialization/
            // - https://revealjs.com/config/
            Reveal.initialize({
                hash: true,
                progress: true,
                transition: 'none',
                controls: false,
                hash: true,

                // Learn about plugins: https://revealjs.com/plugins/
                plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
            });
        </script>
    </body>
</html>
