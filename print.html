<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Getting Started with Aper</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="'./introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="managing_state.html"><strong aria-hidden="true">2.</strong> Managing State</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="building.html"><strong aria-hidden="true">2.1.</strong> Building a state machine</a></li><li class="chapter-item expanded "><a href="atoms.html"><strong aria-hidden="true">2.2.</strong> Constants and Atoms</a></li><li class="chapter-item expanded "><a href="derive.html"><strong aria-hidden="true">2.3.</strong> Derive macro</a></li><li class="chapter-item expanded "><a href="lists.html"><strong aria-hidden="true">2.4.</strong> Lists</a></li><li class="chapter-item expanded "><a href="designing.html"><strong aria-hidden="true">2.5.</strong> Designing with state machines</a></li><li class="chapter-item expanded "><a href="implementing.html"><strong aria-hidden="true">2.6.</strong> Implementing new state machines</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Getting Started with Aper</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Aper is a framework that lets you synchronize program state between users. In Aper, all state is represented as a <strong>state machine</strong>, which means that:</p>
<ol>
<li>It implements the <code>StateMachine</code> trait, which has one method: <code>apply</code>.</li>
<li><strong>All</strong> changes to state flow through the <code>apply</code> method, which takes a single argument
(the type of that argument is up to you).</li>
<li>Updates to state are entirely deterministic. They may depend on the current state and any data
that is contained in the transition value, and nothing else.</li>
</ol>
<p>#1 is enforced by Rust's type system, but it's your responsibility to satisfy #2 and #3. In particular,
accessing the current time, non-determistic random number generators, or external data in <code>apply</code> is
a violation of #3.</p>
<h2 id="keeping-state-in-sync"><a class="header" href="#keeping-state-in-sync">Keeping State in Sync</a></h2>
<p>In principal, the way that Aper keeps state in sync is pretty simple: when a client connects, they receive a full copy of the latest copy of the state. Thereafter, they receive a real-time stream of <code>Transition</code>s. Every client receives the same transitions in the same order, so their states are updated in lockstep. <strong>This is why it's important that <code>apply</code> is deterministic.</strong> If it were not, states could become divergent even if they received the same transition stream.</p>
<p>Note that for this model to work, the client can't immediately apply a transition to its local state, because the client doesn't know whether another client is sending the server a transition at the same time. The client has two options:</p>
<ul>
<li>Accept this latency. Depending on the use-case, a few hundred milliseconds of latency might be tolerable and the simpler model is easier to reason about.</li>
<li>Keep two copies of the state, called <code>optimist</code> and <code>pessimist</code>, as well as a FIFO queue <code>stash</code> of local transitions. As local transitions fire, push them to <code>stash</code> and proactively apply them to <code>optimist</code>. <code>optimist</code> is used to render the view, so local transitions appear automatically. When the server sends a transition, check if it is the next transition in our <code>stash</code>. If so, pop it from the <code>stash</code> and apply it to <code>pessimist</code>. Otherwise, we apply the server-sent transition to <code>pessimist</code>, then clone it and apply every transition in the <code>stash</code> to the clone. This clone becomes the new value of <code>optimist</code>, and the old value is discarded.</li>
</ul>
<p>Aper implements both of these approaches.</p>
<h1 id="managing-state"><a class="header" href="#managing-state">Managing State</a></h1>
<h1 id="building-a-state-machine"><a class="header" href="#building-a-state-machine">Building a state machine</a></h1>
<p>To solidify the concept of state machines, let's start with a simple
example. Here's a simple data structure representing a counter. It stores
an integer and gives us methods to modify it.</p>
<pre><pre class="playground"><code class="language-rust">struct Counter {value: i64}

impl Counter {
    pub fn add(&amp;mut self, i: i64) {
        self.value += i;
    }

    pub fn subtract(&amp;mut self, i: i64) {
        self.value -= i;
    }

    pub fn reset(&amp;mut self, i: i64) {
        self.value = 0;
    }
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p>By inspecting the code, you can see that <code>Counter</code> satisfies condition #3 of a state machine
in Aper: its updates are deterministic. It does <em>not</em>, however, satisfy conditions #1 and
#2: it does not implement <code>StateMachine</code>, and methods other than <code>apply</code> mutate the state.</p>
<p>(By the way, a good way to check if #2 is satisfied is to look for which methods take <code>&amp;mut self</code>.
In an Aper state machine, only <code>apply</code> should need a mutable reference to <code>self</code>.)</p>
<p>We can make this into a state machine like this:</p>
<pre><pre class="playground"><code class="language-rust">use aper::StateMachine;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug, Clone)]
struct Counter {value: i64}

#[derive(Serialize, Deserialize, Debug, Clone)]
enum CounterTransition {
   Add(i64),
   Subtract(i64),
   Reset,
}

impl StateMachine for Counter {
    type Transition = CounterTransition;

    fn apply(&amp;mut self, event: CounterTransition) {
        match event {
            CounterTransition::Add(i) =&gt; {
                self.value += i;
            }
            CounterTransition::Subtract(i) =&gt; {
                self.value -= i;
            }
            CounterTransition::Reset =&gt; {
                self.value = 0;
            }
        }
    }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>Now, any attempt to modify the state of the counter must flow through <code>apply</code> as a <code>CounterTransition</code>. We could use <code>CounterTransition</code>'s constructors directly, but the idiomatic approach that Aper encourages is to implement methods with the same signatures as our original modifiers but that return the <code>Transition</code> type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use aper::StateMachine;
</span><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct Counter {value: i64}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">enum CounterTransition {
</span><span class="boring">   Add(i64),
</span><span class="boring">   Subtract(i64),
</span><span class="boring">   Reset,
</span><span class="boring">}
</span>
impl Counter {
    pub fn add(&amp;self, i: i64) -&gt; CounterTransition {
        CounterTransition::Add(i)
    }

    pub fn subtract(&amp;self, i: i64) -&gt; CounterTransition {
        CounterTransition::Subtract(i)
    }

    pub fn reset(&amp;self, i: i64) -&gt; CounterTransition {
        CounterTransition::Reset
    }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>Notice how these no longer require a mutable reference to <code>self</code>, since they do not actually make any changes, they just return an object <em>representing</em> the change.</p>
<p>I started by showing you how to implement your own state machine because I wanted you to see that it isn't
scary, but implementing state machines from scratch isn't the only way to use Aper. In the next few sections,
I'll show you how to build state machines by composing together primitives provided by Aper.</p>
<h1 id="constants-and-atoms"><a class="header" href="#constants-and-atoms">Constants and Atoms</a></h1>
<p>One way to build state machines is by composing together other state machines. Aper comes with some ready-made state machines to provide common components of state management.</p>
<p>The simplest state machine is a <code>Constant</code>. It's a state machine whose transition has no exposed constructor,
and therefore which can never be modified once it's created. It takes an initial state, and then keeps that
state for the rest of its life.</p>
<pre><pre class="playground"><code class="language-rust">use aper::data_structures::Constant;

fn main() {
    // Construct a constant representing an i64.
    let int_constant = Constant::new(5);
    assert_eq!(&amp;5, int_constant.value());

    // Construct a constant representing a String.
    let string_constant = Constant::new(&quot;Hi Aper&quot;.to_string());

    assert_eq!(&quot;Hi Aper&quot;, string_constant.value().as_str());
}
</code></pre></pre>
<p>An <code>Atom</code> is similar to a <code>Constant</code>, except that it has a transition called <code>ReplaceAtom</code>.</p>
<p>It represents a value that can only be changed by replacing it entirely.</p>
<pre><pre class="playground"><code class="language-rust">use aper::data_structures::Atom;
use aper::StateMachine;

fn main() {
    let mut atom = Atom::new(5);

    // Construct a new `ReplaceAtom` transition.
    let transition = atom.replace(6);

    // Remember, calling `.replace` does not actually change any
    // state -- only a call to `.apply` can do that.
    assert_eq!(&amp;5, atom.value());
    
    atom.apply(transition);

    // Now the change takes effect.
    assert_eq!(&amp;6, atom.value());
}
</code></pre></pre>
<h1 id="derive-macro"><a class="header" href="#derive-macro">Derive macro</a></h1>
<p>If networks were infinitely fast, <code>Atom</code> could be the only state machine we needed: every time the user changed the state, we'd just send the new state to every client and update them all instantly.</p>
<p>In practice, the reason we can't do this is that without infinitely fast networks, it's possible for different users to make conflicting changes. For example, let's say we represented a to-do list item with an Atom:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use aper::data_structures::Atom;

struct ToDoListItem {
    done: bool,
    label: String,
}

type ToDoListAtom = Atom&lt;ToDoListItem&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Suppose you and I both modified this item at the same time. You marked it as done, and I fixed a typo in the label. Your edit hits the server first, so the server's state is briefly updated with the item marked as “done”. But my transition was sent at the same time as yours, and because an Atom captures the entire value, it includes the old value of <code>done</code>! My edit undoes yours.</p>
<p>To avoid this, we can push <code>Atom</code>s deeper down into the data structure. Aper facilitates this with a <code>derive</code> macro:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use aper::StateMachine;
use aper::data_structures::Atom;
use aper_derive::StateMachine;
use serde::{Serialize, Deserialize};

#[derive(StateMachine, Serialize, Deserialize, Debug, Clone)]
struct ToDoListItem {
    done: Atom&lt;bool&gt;,
    label: Atom&lt;String&gt;,
}

impl ToDoListItem {
    pub fn new(label: String) -&gt; Self {
        ToDoListItem {
            done: Atom::new(false),
            label: Atom::new(label),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, we can represent these same transitions in a way that they don't conflict.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use aper::StateMachine;
</span><span class="boring">use aper::data_structures::Atom;
</span><span class="boring">use aper_derive::StateMachine;
</span><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">
</span><span class="boring">#[derive(StateMachine, Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct ToDoListItem {
</span><span class="boring">    done: Atom&lt;bool&gt;,
</span><span class="boring">    label: Atom&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ToDoListItem {
</span><span class="boring">    pub fn new(label: String) -&gt; Self {
</span><span class="boring">        ToDoListItem {
</span><span class="boring">            done: Atom::new(false),
</span><span class="boring">            label: Atom::new(label),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn main() {
    let mut item = ToDoListItem::new(&quot;Buy gorceries&quot;.to_string());

    assert_eq!(&quot;Buy gorceries&quot;, item.label().value());
    assert_eq!(&amp;false, item.done().value());

    let mark_done = item.map_done(|d| d.replace(true));
    let fix_typo = item.map_label(|d| d.replace(&quot;Buy groceries&quot;.to_string()));

    // Unlike before, the order in which the transitions are applied
    // does not matter.
    item.apply(mark_done);
    item.apply(fix_typo);

    assert_eq!(&quot;Buy groceries&quot;, item.label().value());
    assert_eq!(&amp;true, item.done().value());
}
</code></pre></pre>
<p>The methods <code>map_done</code> and <code>map_label</code> are generated by the derive macro by prepending <code>map_</code> to each field. They take a single argument, which is a function from the type of that field (e.g. <code>Atom&lt;bool&gt;</code>) to a type of that field's transition (<code>ReplaceAtom&lt;bool&gt;</code>). They return a transition that can be applied to the parent struct (<code>ToDoListItem</code>), which combines the transition you constructed in the map with an indication of which field it is to be applied to.</p>
<p>To better understand this approach, it might be good to understand what we <em>can't</em> do. For one thing, we can't apply the field's transition to it directly:</p>
<pre><code class="language-rust ignore">fn main() {
    let mut item = ToDoListItem::new(&quot;Buy gorceries&quot;.to_string());

    let mark_done = item.done().replace(true);

    // This will fail to compile because `done()` exposes a read-only
    // borrow of the Atom.
    item.done().apply(mark_done);
}
</code></pre>
<p>Nor can we apply the <code>Atom</code>'s state change directly to the <code>ToDoListItem</code>:</p>
<pre><code class="language-rust ignore">fn main() {
    let mut item = ToDoListItem::new(&quot;Buy gorceries&quot;.to_string());

    let mark_done = item.done().replace(true);

    // This will fail to compile because `mark_done` is a `ReplaceAtom&lt;bool&gt;`
    // but `item.apply()` expects a `ToDoListItemTransition`.
    item.apply(mark_done);
}
</code></pre>
<h1 id="lists"><a class="header" href="#lists">Lists</a></h1>
<p>Another built-in data structure is the <code>List</code>. Lists are ordered sequence that you can iterate over, and arbitrarily insert/remove from. The values in a list are themselves state machines (if you never want to modify the inner state of values on a list, you can use <code>Constant</code> as a wrapper around the values.)</p>
<p>Let's use the <code>ToDoListItem</code> from the last section to create a <code>ToDoList</code></p>
<pre><pre class="playground"><code class="language-rust">use aper::data_structures::List;
<span class="boring">use aper::StateMachine;
</span><span class="boring">use aper::data_structures::Atom;
</span><span class="boring">use aper_derive::StateMachine;
</span><span class="boring">use serde::{Serialize, Deserialize};
</span><span class="boring">use std::default::Default;
</span><span class="boring">
</span><span class="boring">#[derive(StateMachine, Serialize, Deserialize, Debug, Clone)]
</span><span class="boring">struct ToDoListItem {
</span><span class="boring">    done: Atom&lt;bool&gt;,
</span><span class="boring">    label: Atom&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ToDoListItem {
</span><span class="boring">    pub fn new(label: String) -&gt; Self {
</span><span class="boring">        ToDoListItem {
</span><span class="boring">            done: Atom::new(false),
</span><span class="boring">            label: Atom::new(label),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span>
<span class="boring">fn main() {
</span>let mut to_do_list: List&lt;ToDoListItem&gt; = Default::default();

// Initially, the list is empty. We need to add things to it.

// Append generates and returns an identifier which we can later
// use to identify the record.
let (dog_food_id, dog_food_transition) = to_do_list.append(
		ToDoListItem::new(&quot;Get dog food&quot;.to_string())
);

to_do_list.apply(dog_food_transition);

let (lunch_id, lunch_transition) = to_do_list.append(
		ToDoListItem::new(&quot;Make lunch&quot;.to_string())
);

to_do_list.apply(lunch_transition);

let emphasize_dog_food = to_do_list.map_item(dog_food_id,
	|it| it.map_label(|lbl| lbl.replace(&quot;Get DOG FOOD!&quot;.to_string())));

to_do_list.apply(emphasize_dog_food);

let mark_lunch_done = to_do_list.map_item(lunch_id,
	|it| it.map_done(|done| done.replace(true)));
<span class="boring">}
</span></code></pre></pre>
<p>If this method of calling <code>map_*</code> seems tedious, don't worry! Later when we actually implement the UI, it will take care of itself due to the fact that the view hierarchy usually maps directly to the state machine hierarchy.</p>
<h1 id="designing-with-state-machines"><a class="header" href="#designing-with-state-machines">Designing with state machines</a></h1>
<p>When working with state machines, situations often come up where there are multiple ways to represent the same state. We saw this already with the <code>ToDoListItem</code> example, where the state could be either:</p>
<ol>
<li>A single <code>Atom</code> of a <code>ToDoListItem</code> struct with primitive types for fields, or</li>
<li>A struct with two <code>Atom</code> fields, with each atom containing a primitive type.</li>
</ol>
<p>Both approaches are exactly equivalent when it comes to representing data <em>at rest</em>. They differ only in how merges are handled when (in this case) multiple fields are modified at the same time. For the to-do list example, we decided that #2 was the right approach, but there may be other data types for which #1 is the best approach.</p>
<p>This points out an important aspect of Aper that is central to its philosophy. Aper's focus is on providing <strong>semantics for describing what happens when concurrent modifications happen to the same data structure</strong>. The underlying storage Aper uses to do this is incidental.</p>
<h1 id="implementing-new-state-machines"><a class="header" href="#implementing-new-state-machines">Implementing new state machines</a></h1>
<p>So far, we've created state machines by composing primitive, pre-built state machines and using the derive macro. For more flexibility, you can also implement your own.</p>
<p>I teased with an example of this with the <code>Counter</code>. As a slightly more complex example, let's implement Tic Tac Toe.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use aper::StateMachine;
use serde::{Serialize, Deserialize};

#[derive(Clone, Copy, Serialize, Deserialize, Debug, PartialEq)]
enum Player {
    X,
    O,
}

// The board is a 3x3 grid, flattened into an array:
// 0 | 1 | 2
// --+---+--
// 3 | 4 | 5
// --+---+--
// 6 | 7 | 8

#[derive(Serialize, Deserialize, Clone, Debug)]
struct TicTacToe {
    board: [Option&lt;Player&gt;; 9],
    next_player: Option&lt;Player&gt;, // None if the game has ended.
}

impl TicTacToe {
    pub fn new() -&gt; TicTacToe {
        TicTacToe {
            board: [None; 9],
            next_player: Some(Player::O),
        }
    }

    fn check_seq(&amp;self, seq: &amp;[usize; 3]) -&gt; Option&lt;Player&gt; {
        let v1 = self.board[seq[0]]?;
        let v2 = self.board[seq[1]]?;
        let v3 = self.board[seq[2]]?;

        if (v1 == v2) &amp;&amp; (v2 == v3) {
            Some(v1)
        } else {
            None
        }
    }

  fn winner(&amp;self) -&gt; Option&lt;Player&gt; {
        let seq_to_check: [[usize; 3]; 8] = [
            [0, 1, 2],
            [3, 4, 5],
            [6, 7, 8],
            [0, 3, 6],
            [1, 4, 7],
            [2, 5, 8],
            [0, 4, 8],
            [2, 4, 6],
        ];

        for seq in &amp;seq_to_check {
            let result = self.check_seq(seq);
            if result.is_some() {
                return result;
            }
        }

        None
    }
}

#[derive(Serialize, Deserialize, Clone, Debug)]
struct TicTacToePlay(usize);

impl StateMachine for TicTacToe {
    type Transition = TicTacToePlay;
    
    fn apply(&amp;mut self, play: TicTacToePlay) {
        let this_player = if let Some(this_player) = self.next_player {
            this_player
        } else {
            // The game has already been won, don't accept another play.
            return;
        };
        let TicTacToePlay(play_index) = play;
        if self.board[play_index].is_some() {
            // Can't play over something that has already been played!
            return;
        }
        // Insert this play into the board.
        self.board[play_index] = self.next_player;
        
        // Check for a winner.
        if self.winner().is_some() {
            self.next_player = None;
            return;
        }

        // Update the next player.
        if Player::X == this_player {
            self.next_player = Some(Player::O);
        } else {
            self.next_player = Some(Player::X);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
